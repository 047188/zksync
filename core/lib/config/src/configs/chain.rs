/// External uses
use serde::Deserialize;
// Local uses
use crate::envy_load;

#[derive(Debug, Deserialize)]
pub struct ChainConfig {
    /// Proving / circuit data configuration.
    pub circuit: Circuit,
    /// L1 parameters configuration.
    pub eth: Eth,
    /// State keeper / block generating configuration.
    pub state_keeper: StateKeeper,
}

impl ChainConfig {
    pub fn from_env() -> Self {
        Self {
            circuit: envy_load!("circuit", "CHAIN_CIRCUIT_"),
            eth: envy_load!("eth", "CHAIN_ETH_"),
            state_keeper: envy_load!("state_keeper", "CHAIN_STATE_KEEPER_"),
        }
    }
}

#[derive(Debug, Deserialize)]
pub struct Circuit {
    /// Path to the directory with the cryptographical keys. Relative to `$ZKSYNC_HOME`.
    pub key_dir: String,
    /// Actual supported block chunks sizes by verifier contract (determined by circuit size on setup boundaries).
    pub supported_block_chunks_sizes: Vec<usize>,
    /// Setup power needed to proof block of certain size (goes in the same order as the previous field,
    /// so both arrays can be `zip`ped together).
    pub supported_block_chunks_sizes_setup_powers: Vec<usize>,
    /// Depth of the Account Merkle tree.
    pub account_tree_depth: usize,
    /// Depth of the Balance Merkle tree.
    pub balance_tree_depth: usize,
}

#[derive(Debug, Deserialize)]
pub struct Eth {
    /// Since withdraw is an expensive operation, we have to limit amount of
    /// withdrawals in one block to not exceed the gas limit in prover.
    /// If this threshold is reached, block will be immediately sealed and
    /// the remaining withdrawals will go to the next block.
    pub max_number_of_withdrawals_per_block: usize,
    /// Name of the used Ethereum network, e.g. `localhost` or `rinkeby`.
    pub eth_network: String,
}

#[derive(Debug, Deserialize)]
pub struct StateKeeper {
    /// Block sizes to be generated by server. Has to contain only values set in the `supported_block_chunks_sizes`,
    /// otherwise block will never be proven. This list can contain not all the values though: e.g. for local
    /// development usually a couple of smallest block sizes is enough.
    pub block_chunk_sizes: Vec<usize>,
    /// Time between two miniblocks created by mempool / block_proposer.
    pub miniblock_iteration_interval: u64,
    /// Maximum amount of miniblock iterations before sealing the block.
    pub miniblock_iterations: u64,
    /// Maximum amount of miniblock iterations in case of block containing a fast withdrawal request.
    pub fast_block_miniblock_iterations: u64,
}
